# This code was auto generated by with these options:
# #auto_url#

# :option-max-conflicted-files
    MAX_CONFLICTED_FILES=2
# /option-max-conflicted-chars
# :option-delta
    DELTA_CHAR="△"
# /option-delta
# :option-conflict
    CONFLICT_CHAR="☢"
# /option-conflict
# :option-bisecting
    BISECTING_TEXT="bisecting"
# /option-bisecting
# :option-nobranch
    NOBRANCH_TEXT="no branch!"
# /option-nobranch
# :option-rebase
    REBASE_TEXT="✂ ʀebase"
# /option-rebase
# :option-submodule
    SUBMODULE_TEXT="[submodule] "
# /option-submodule

# :color-list
    # Colors for prompt
    COLOR_RED=$(tput sgr0 && tput setaf 1)
    COLOR_GREEN=$(tput sgr0 && tput setaf 2)
    COLOR_YELLOW=$(tput sgr0 && tput setaf 3)
    COLOR_BLUE=$(tput sgr0 && tput setaf 4)
    COLOR_MAGENTA=$(tput sgr0 && tput setaf 5)
    COLOR_CYAN=$(tput sgr0 && tput setaf 6)
    COLOR_GRAY=$(tput sgr0 && tput setaf 7)
    COLOR_WHITE=$(tput sgr0 && tput setaf 7 && tput bold)
    COLOR_LIGHTRED=$(tput sgr0 && tput setaf 1 && tput bold)
    COLOR_LIGHTGREEN=$(tput sgr0 && tput setaf 2 && tput bold)
    COLOR_LIGHTYELLOW=$(tput sgr0 && tput setaf 3 && tput bold)
    COLOR_LIGHTBLUE=$(tput sgr0 && tput setaf 4 && tput bold)
    COLOR_LIGHTMAGENTA=$(tput sgr0 && tput setaf 5 && tput bold)
    COLOR_LIGHTCYAN=$(tput sgr0 && tput setaf 6 && tput bold)

    COLOR_RESET=$(tput sgr0)

# /color-list
# :hg
    if [ -z "`echo $(hg prompt \"abort\" 2>&1) | grep abort`" ]; then
        echo "hg-prompt not installed. Suggest http://sjl.bitbucket.org/hg-prompt/installation/"
    fi

    _hg_dir=""
    function _hg_check {
        [ -d ".hg" ] && _hg_dir=`pwd`
        base_dir="."
        while [ -d "$base_dir/../.hg" ]; do base_dir="$base_dir/.."; done
        if [ -d "$base_dir/.hg" ]; then
            _hg_dir=`cd "$base_dir"; pwd`
            return 0
        else
            return 1
        fi
    }
# /hg

# :svn
    _svn_dir=""
    function _svn_check {
        parent=""
        grandparent="."

        while [ -d "$grandparent/.svn" ]; do
            parent=$grandparent
            grandparent="$parent/.."
        done

        if [ ! -z "$parent" ]; then
            _svn_dir=`cd "$parent"; pwd`
            return 0
        else
            return 1
        fi
    }
# /svn

# :git
    _git_dir=""
    _git_svn_dir=""
    function _git_check {
        _git_dir=`git rev-parse --show-toplevel 2> /dev/null`
        if [[ "$_git_dir" == "" ]]; then
            return 1
        else
            _gsvn_check=`cd "$_git_dir"; ls .git/svn/.metadata 2> /dev/null`

            if [[ ! -z "$_gsvn_check" ]]; then
                _git_svn_dir=$_git_dir
            fi
            return 0
        fi
    }
# /git

# :git-submodule
    function is_submodule() {
        local parent_git=`cd "$_git_dir/.." && git rev-parse --show-toplevel 2> /dev/null`
        if [[ -n $parent_git ]]; then
            local submodules=`cd "$parent_git" && git submodule --quiet foreach 'echo $path'`
            for line in $submodules; do
                cd "$parent_git/$line"
                if [[ `pwd` = $_git_dir ]]; then return 0; fi
            done
        fi
        return 1
    }

# /git-submodule
dvcs_function="
    # Figure out what repo we are in
    # :git
        _git_check \
    # /git
        # :hg
            || _hg_check \
        # /hg
        # :svn
            || _svn_check
        # /svn

    # Build the prompt!
    prompt=\"\"

    # :git
        # If we are in git ...
        if [ -n \"\$_git_dir\" ]; then
            # find current branch
            gitBranch=\$(git symbolic-ref HEAD 2> /dev/null)
            gitStatus=\`git status\`

            # :git-rebase
                # Figure out if we are rebasing
                if [[ -d \"\$_git_dir/.git/rebase-apply\" || -d \"\$_git_dir/.git/rebase-merge\" ]]; then
                    is_rebase=1
                fi
            # /git-rebase

            # Figure out current branch, or if we are bisecting, or lost in space
            bisecting=\"\"
            if [ -z \"\$gitBranch\" ]; then
                # :git-rebase
                if [ -n \"\$is_rebase\" ]; then
                    rebase_prompt=\" \\[\$COLOR_LIGHT_CYAN\\]\"
                    rebase_prompt=\$rebase_prompt\"\\[`tput sc`\\]  \\[`tput rc`\\]\\[\$REBASE_TEXT\\] \"
                    rebase_prompt=\$rebase_prompt\"\\[\$COLOR_YELLOW\\]\"
                else
                # /git-rebase
                # :git-bisect
                    bisect=\$(git rev-list --bisect 2> /dev/null | cut -c1-7)
                    if [ -z \"\$bisect\" ]; then
                # /git-bisect
                gitBranch=\"\\[\$color-option-nobranch\\]\$NOBRANCH_TEXT\\[\$color-git\\]\"
                # :git-bisect
                else
                    bisecting=\"\\[\$color-git-bisect\\]\$BISECTING_TEXT:\"\$bisect\"\\[\$color-git\\]\"
                    gitBranch=\"\"
                fi
                # /git-bisect
                # :git-rebase
                fi
                # /git-rebase
            fi
            gitBranch=\${gitBranch#refs/heads/}
            #: git-svn
            if [ -z \"\$bisect\" ]; then
                if [ -n \"\$_git_svn_dir\" ]; then
                    gitBranch=\"\\[\$COLOR_DARK_BLUE\\]git-svn\\[\$COLOR_YELLOW\\] \$gitBranch\"
                fi
            fi
            # /git-svn

            
            # :git-rebase
            if [ -z \"\$is_rebase\" ]; then
            # /git-rebase
            # :git-modified
                # changed *tracked* files in local directory?
                gitChange=\$(echo \$gitStatus | ack 'modified:|deleted:|new file:')
                if [ -n \"\$gitChange\" ]; then
                    gitChange=\"\\[\$color-git-modified\\] \\[`tput sc`\\]  \\[`tput rc`\\]\\[\$DELTA_CHAR\\] \"
                fi
            # /git-modified
            # :git-rebase
            fi
            # /git-rebase

            # :git-branch
                # output the branch and changed character if present
                prompt=\$prompt\"\\[\$color-git\\] (\"

                # :git-submodule
                    if is_submodule; then
                        prompt=\$prompt\"\\[\$color-git-submodule\\]\$SUBMODULE_TEXT\\[\$color-git\\]\"
                    fi
                # /git-submodule

                # :git-prefix
                    prefix=\"\\[\$color-git-prefix\\]git:\\[\$color-git\\]\"
                # /git-prefix
                prompt=\$prompt\$prefix\$gitBranch\$bisecting
            # /git-branch
            # :git-revno
                revNo=\$(git rev-parse HEAD 2> /dev/null | cut -c1-7) || return

                # If bisecting don't output revno
                if [ -z \"\$bisecting\" ] && [ -z \"\$noBranch\" ];then
                    prompt=\$prompt\":\$revNo\"
                fi
            # /git-revno
            # :git-ontag
                tag=\`git describe --tags --exact 2> /dev/null\`
                if [ -n \"\$tag\" ]; then
                    prompt=\"\$prompt\\[\$color-git-ontag\\] \\\"\$tag\\\"\\[\$color-git\\]\"
                fi
            # /git-ontag
            prompt=\$prompt\"\$gitChange\\[\$color-git\\])\\[\$COLOR_RESET\\]\"

            # :git-ahead
                # How many local commits do you have ahead of origin?
                num=\$(echo \$gitStatus | grep \"Your branch is ahead of\" | awk '{split(\$0,a,\" \"); print a[13];}') || return
                if [ -n \"\$num\" ]; then
                    prompt=\$prompt\"\\[\$color-git-ahead\\] +\$num\"
                fi
            # /git-ahead

            # :git-conflicted
                # any conflicts? (sed madness is to remove line breaks)
                files=\$(git ls-files -u | cut -f 2 | sort -u | sed '$(($MAX_CONFLICTED_FILES+1)),1000d' | sed -e :a -e '\$!N;s/\\\n/, /;ta' -e 'P;D')
            # /git-conflicted
        fi
    # /git

    # :hg
        # If we are in mercurial ...
        if [ -n \"\$_hg_dir\" ]; then
            hgBranch=\`cat \"\$_hg_dir/.hg/branch\"\`

            hgPrompt=\"s\"
            # :hg-modified
                hgPrompt=\"\$hgPrompt{status|modified}\"
            # /hg-modified

            hgPrompt=\"\$hgPrompt n\"
            # :hg-revno
                hgPrompt=\"\$hgPrompt{node}\"
            # /hg-revno

            hgPrompt=\"\$hgPrompt p\"
            # :hg-patches
                hgPrompt=\"\$hgPrompt{patches|hide_unapplied|join(,)}\"
            # /hg-patches

            promptOptions=(\`hg prompt \"\$hgPrompt\" | tr -s ':' ' '\`)

            # :hg-modified
                hgm=\${promptOptions[0]:1}
                if [ -n \"\$hgm\" ]; then
                    hgChange=\"\\[\$color-hg-modified\\] \\[`tput sc`\\]  \\[`tput rc`\\]\\[\$DELTA_CHAR\\]\"
                fi
            # /hg-modified

            # :hg-branch
                # output branch and changed character if present
                prompt=\$prompt\"\\[\$color-hg\\] (\"
                
                # :hg-prefix
                    prefix=\"\\[\$color-hg-prefix\\]hg:\\[\$color-hg\\]\"
                # /hg-prefix
                prompt=\$prompt\"\${prefix}\${hgBranch}\"

                # :hg-bisect
                    bisecting=\$(hg bisect 2> /dev/null | head -n 1)
                    bisecting=\${bisecting:20:7}

                    if [ -z \"\$bisecting\" ]; then
                # /hg-bisect
                    prompt=\$prompt
                    # :hg-revno
                        prompt=\$prompt\":\${promptOptions[1]:1:7}\"
                    # /hg-revno
                # :hg-bisect
                    else
                        prompt=\"\$prompt\\[\$color-hg-bisect\\]:\$BISECTING_TEXT:\"\$bisecting\"\\[\$color-hg\\]\"
                    fi
                # /hg-bisect
                prompt=\$prompt\"\$hgChange\"
                # :hg-patches
                    patches=\${promptOptions[2]:1}
                    if [ -n \"\$patches\" ];then
                        prompt=\$prompt\"\\[\$color-hg-patches\\] [\$patches]\\[\$color-hg\\]\"
                    fi
                # /hg-patches
                prompt=\$prompt\")\"
            # /hg-branch

            # :hg-conflicted
            # Conflicts?
                files=\$(hg resolve -l | grep \"U \" | sed '$(($MAX_CONFLICTED_FILES+1)),1000d' | awk '{split(\$0,a,\" \"); print a[2];}') || return
            # /hg-conflicted
        fi
    # /hg

    # :svn
        # If we are in subversion ...
        if [ -n \"\$_svn_dir\" ]; then

            # :svn-changed
                # changed files in local directory? NOTE: This command is the slowest of the bunch
                svnChange=\$(svn status | ack \"^M|^!\" | wc -l)
                if [[ \"\$svnChange\" != \"       0\" ]]; then
                    svnChange=\"\\[\$color-svn-modified\\] \\[`tput sc`\\]  \\[`tput rc`\\]\\[\$DELTA_CHAR\\] \"
                else
                    svnChange=\"\"
                fi
            # /svn-changed

            # revision number (instead of branch name, silly svn)
            revNo=\`svnversion --no-newline\`
            prompt=\$prompt\"\\[\$color-svn\\] (svn\"
            # :svn-revno
                prompt=\$prompt\"\\[\$color-svn-revno\\] :\$revNo\\[\$color-svn\\] \"
            # /svn-revno
            prompt=\$prompt\"\$svnChange)\\[\$COLOR_RESET\\]\"
        fi
    # /svn

    # :conflicts
        # Show conflicted files if any
        if [ -n \"\$files\" ]; then
            prompt=\$prompt\" \\[\$color-conflicted\\](\\[\$color-conflict-char\\]\"
            prompt=\$prompt\"\\[`tput sc`\\]  \\[`tput rc`\\]\\[\$color-conflict-char\\]\\[\$CONFLICT_CHAR\\] \"
            prompt=\$prompt\"\\[\$color-conflicted\\] \${files})\"
        fi

    # /conflicts
    echo -e \$prompt"
# End code auto generated by http://andrewray.me/bash-prompt-builder/index.html

PS1="\$(${dvcs_function})\[$COLOR_RESET\] \$ "
